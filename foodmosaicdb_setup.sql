-- FoodMosaic Database Full Schema Setup
-- Generated by combining all migrations and the latest schema

-- 1. ENUM TYPES
CREATE TYPE public.user_role AS ENUM ('admin', 'staff');
CREATE TYPE public.work_order_status AS ENUM (
  'CREATED',
  'PROCURED', 
  'IN-STOCK',
  'PROCESSED',
  'SHIPPED',
  'EXECUTED',
  'COMPLETE'
);

-- 2. TRIGGER FUNCTION (must be before any table triggers)
CREATE OR REPLACE FUNCTION public.update_updated_at_column()
RETURNS trigger
LANGUAGE plpgsql
AS $$
BEGIN
    NEW.updated_at = now();
    RETURN NEW;
END;
$$;

-- 3. TABLES
CREATE TABLE public.profiles (
  id uuid PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  username text NOT NULL,
  email text NOT NULL,
  role user_role NOT NULL DEFAULT 'staff',
  active boolean NOT NULL DEFAULT true,
  created_at timestamp without time zone NOT NULL DEFAULT now(),
  updated_at timestamp without time zone NOT NULL DEFAULT now()
);
ALTER TABLE public.profiles ENABLE ROW LEVEL SECURITY;
CREATE TRIGGER update_profiles_updated_at
  BEFORE UPDATE ON public.profiles
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();

-- 4. FUNCTIONS (must be before any policy or table that uses them)
CREATE OR REPLACE FUNCTION public.get_user_role(user_id uuid)
RETURNS user_role
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT role FROM public.profiles WHERE id = user_id;
$$;

CREATE OR REPLACE FUNCTION public.is_admin(user_id uuid)
RETURNS boolean
LANGUAGE sql
STABLE
SECURITY DEFINER
AS $$
  SELECT EXISTS (
    SELECT 1 FROM public.profiles 
    WHERE id = user_id AND role = 'admin' AND active = true
  );
$$;

-- 5. RLS Policies for profiles
CREATE POLICY "Admins can view all profiles"
ON public.profiles
FOR SELECT
TO authenticated
USING (public.is_admin(auth.uid()) OR id = auth.uid());
CREATE POLICY "Admins can insert profiles"
ON public.profiles
FOR INSERT
TO authenticated
WITH CHECK (public.is_admin(auth.uid()));
CREATE POLICY "Admins can update profiles"
ON public.profiles
FOR UPDATE
TO authenticated
USING (public.is_admin(auth.uid()));
CREATE POLICY "No one can delete profiles"
ON public.profiles
FOR DELETE
TO authenticated
USING (false);

-- 6. INGREDIENTS TABLE
CREATE TABLE public.ingredients (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP NOT NULL DEFAULT now()
);
CREATE TRIGGER update_ingredients_updated_at
  BEFORE UPDATE ON public.ingredients
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
ALTER TABLE public.ingredients ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins can view all ingredients" 
  ON public.ingredients 
  FOR SELECT 
  USING (public.is_admin(auth.uid()));
CREATE POLICY "Admins can insert ingredients" 
  ON public.ingredients 
  FOR INSERT 
  WITH CHECK (public.is_admin(auth.uid()));
CREATE POLICY "Admins can update ingredients" 
  ON public.ingredients 
  FOR UPDATE 
  USING (public.is_admin(auth.uid()));
CREATE POLICY "Admins can delete ingredients" 
  ON public.ingredients 
  FOR DELETE 
  USING (public.is_admin(auth.uid()));
CREATE POLICY "Staff can view all ingredients" 
  ON public.ingredients 
  FOR SELECT 
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() 
      AND role = 'staff' 
      AND active = true
    )
  );
CREATE INDEX idx_ingredients_active ON public.ingredients(active);
CREATE INDEX idx_ingredients_name ON public.ingredients(name);

-- 7. COMPOUNDS & COMPOUND_INGREDIENTS
CREATE TABLE public.compounds (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  unit_of_measurement TEXT,
  tags TEXT[] DEFAULT '{}',
  active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER update_compounds_updated_at
  BEFORE UPDATE ON public.compounds
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();
ALTER TABLE public.compounds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admin users can manage compounds" ON public.compounds
FOR ALL
TO authenticated
USING (public.get_user_role(auth.uid()) = 'admin')
WITH CHECK (public.get_user_role(auth.uid()) = 'admin');
CREATE POLICY "Staff users can view compounds" ON public.compounds
FOR SELECT
TO authenticated
USING (public.get_user_role(auth.uid()) = 'staff');

CREATE TABLE public.compound_ingredients (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  compound_id UUID NOT NULL REFERENCES public.compounds(id) ON DELETE CASCADE,
  ingredient_id UUID NOT NULL REFERENCES public.ingredients(id) ON DELETE CASCADE,
  quantity NUMERIC NOT NULL DEFAULT 1,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  UNIQUE(compound_id, ingredient_id)
);
ALTER TABLE public.compound_ingredients ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admin users can manage compound ingredients" ON public.compound_ingredients
FOR ALL
TO authenticated
USING (public.get_user_role(auth.uid()) = 'admin')
WITH CHECK (public.get_user_role(auth.uid()) = 'admin');
CREATE POLICY "Staff users can view compound ingredients" ON public.compound_ingredients
FOR SELECT
TO authenticated
USING (public.get_user_role(auth.uid()) = 'staff');
CREATE INDEX idx_compound_ingredients_compound_id ON public.compound_ingredients(compound_id);
CREATE INDEX idx_compound_ingredients_ingredient_id ON public.compound_ingredients(ingredient_id);

-- 8. PRODUCTS & PRODUCT_INGREDIENTS & PRODUCT_COMPOUNDS
CREATE TABLE public.products (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  pack_type TEXT,
  client_note TEXT,
  tags TEXT[] DEFAULT '{}',
  remarks TEXT,
  sale_price DECIMAL(10,2),
  active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMP NOT NULL DEFAULT now(),
  updated_at TIMESTAMP NOT NULL DEFAULT now()
);
CREATE TRIGGER update_products_updated_at
  BEFORE UPDATE ON public.products
  FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();
ALTER TABLE public.products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Authenticated users can view products" 
  ON public.products 
  FOR SELECT 
  TO authenticated 
  USING (true);
CREATE POLICY "Admin users can insert products" 
  ON public.products 
  FOR INSERT 
  TO authenticated 
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'admin'
    )
  );
CREATE POLICY "Admin users can update products" 
  ON public.products 
  FOR UPDATE 
  TO authenticated 
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'admin'
    )
  );
CREATE POLICY "Admin users can delete products" 
  ON public.products 
  FOR DELETE 
  TO authenticated 
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'admin'
    )
  );
CREATE INDEX idx_products_active ON public.products(active);
CREATE INDEX idx_products_name ON public.products(name);

CREATE TABLE public.product_ingredients (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  product_id UUID NOT NULL REFERENCES public.products(id) ON DELETE CASCADE,
  ingredient_id UUID NOT NULL REFERENCES public.ingredients(id) ON DELETE CASCADE,
  quantity DECIMAL(10,3) NOT NULL DEFAULT 1,
  created_at TIMESTAMP NOT NULL DEFAULT now(),
  UNIQUE(product_id, ingredient_id)
);
ALTER TABLE public.product_ingredients ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins can view all product ingredients" 
  ON public.product_ingredients 
  FOR SELECT 
  USING (public.is_admin(auth.uid()));
CREATE POLICY "Admins can insert product ingredients" 
  ON public.product_ingredients 
  FOR INSERT 
  WITH CHECK (public.is_admin(auth.uid()));
CREATE POLICY "Admins can update product ingredients" 
  ON public.product_ingredients 
  FOR UPDATE 
  USING (public.is_admin(auth.uid()));
CREATE POLICY "Admins can delete product ingredients" 
  ON public.product_ingredients 
  FOR DELETE 
  USING (public.is_admin(auth.uid()));
CREATE INDEX idx_product_ingredients_product_id ON public.product_ingredients(product_id);
CREATE INDEX idx_product_ingredients_ingredient_id ON public.product_ingredients(ingredient_id);

CREATE TABLE public.product_compounds (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  product_id UUID NOT NULL REFERENCES public.products(id) ON DELETE CASCADE,
  compound_id UUID NOT NULL REFERENCES public.compounds(id) ON DELETE CASCADE,
  quantity NUMERIC NOT NULL DEFAULT 1,
  created_at TIMESTAMP WITHOUT TIME ZONE NOT NULL DEFAULT now(),
  UNIQUE(product_id, compound_id)
);
ALTER TABLE public.product_compounds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow all authenticated users to view product_compounds" ON public.product_compounds
  FOR SELECT TO authenticated USING (true);
CREATE POLICY "Allow all authenticated users to insert product_compounds" ON public.product_compounds
  FOR INSERT TO authenticated WITH CHECK (true);
CREATE POLICY "Allow all authenticated users to update product_compounds" ON public.product_compounds
  FOR UPDATE TO authenticated USING (true);
CREATE POLICY "Allow all authenticated users to delete product_compounds" ON public.product_compounds
  FOR DELETE TO authenticated USING (true);

-- 9. RECIPES, RECIPE_INSTRUCTIONS, RECIPE_PRODUCTS, RECIPE_COMPOUNDS
CREATE TABLE public.recipes (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  active BOOLEAN NOT NULL DEFAULT true,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER update_recipes_updated_at
  BEFORE UPDATE ON public.recipes
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();
ALTER TABLE public.recipes ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins can manage all recipes" ON public.recipes
  FOR ALL TO authenticated
  USING (public.is_admin(auth.uid()));
CREATE POLICY "Staff can view all recipes" ON public.recipes
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'staff' AND active = true
    )
  );

CREATE TABLE public.recipe_instructions (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  recipe_id UUID NOT NULL REFERENCES public.recipes(id) ON DELETE CASCADE,
  sequence_number INTEGER NOT NULL,
  instruction_text TEXT NOT NULL,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  UNIQUE(recipe_id, sequence_number)
);
ALTER TABLE public.recipe_instructions ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins can manage all recipe instructions" ON public.recipe_instructions
  FOR ALL TO authenticated
  USING (public.is_admin(auth.uid()));
CREATE POLICY "Staff can view all recipe instructions" ON public.recipe_instructions
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'staff' AND active = true
    )
  );
CREATE INDEX idx_recipe_instructions_recipe_id ON public.recipe_instructions(recipe_id);
CREATE INDEX idx_recipe_instructions_sequence ON public.recipe_instructions(recipe_id, sequence_number);
CREATE INDEX idx_recipe_instructions_text_search ON public.recipe_instructions USING gin(to_tsvector('english', instruction_text));

CREATE TABLE public.recipe_products (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  recipe_id UUID NOT NULL REFERENCES public.recipes(id) ON DELETE CASCADE,
  product_id UUID NOT NULL REFERENCES public.products(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  UNIQUE(recipe_id, product_id)
);
ALTER TABLE public.recipe_products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins can manage all recipe products" ON public.recipe_products
  FOR ALL TO authenticated
  USING (public.is_admin(auth.uid()));
CREATE POLICY "Staff can view all recipe products" ON public.recipe_products
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'staff' AND active = true
    )
  );
CREATE INDEX idx_recipe_products_recipe_id ON public.recipe_products(recipe_id);
CREATE INDEX idx_recipe_products_product_id ON public.recipe_products(product_id);

CREATE TABLE public.recipe_compounds (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  recipe_id UUID NOT NULL REFERENCES public.recipes(id) ON DELETE CASCADE,
  compound_id UUID NOT NULL REFERENCES public.compounds(id) ON DELETE CASCADE,
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  UNIQUE(recipe_id, compound_id)
);
ALTER TABLE public.recipe_compounds ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Admins can manage all recipe compounds" ON public.recipe_compounds
  FOR ALL TO authenticated
  USING (public.is_admin(auth.uid()));
CREATE POLICY "Staff can view all recipe compounds" ON public.recipe_compounds
  FOR SELECT TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'staff' AND active = true
    )
  );
CREATE INDEX idx_recipe_compounds_recipe_id ON public.recipe_compounds(recipe_id);
CREATE INDEX idx_recipe_compounds_compound_id ON public.recipe_compounds(compound_id);

-- 10. WORK ORDERS & WORK ORDER PRODUCTS
CREATE TABLE public.work_orders (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  name TEXT NOT NULL,
  description TEXT,
  remarks TEXT,
  status work_order_status NOT NULL DEFAULT 'CREATED',
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  updated_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now()
);
CREATE TRIGGER update_work_orders_updated_at
  BEFORE UPDATE ON public.work_orders
  FOR EACH ROW
  EXECUTE FUNCTION public.update_updated_at_column();
ALTER TABLE public.work_orders ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Everyone can view work orders" 
  ON public.work_orders 
  FOR SELECT 
  TO authenticated
  USING (true);
CREATE POLICY "Only admins can insert work orders" 
  ON public.work_orders 
  FOR INSERT 
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'admin' AND active = true
    )
  );
CREATE POLICY "Only admins can update work orders" 
  ON public.work_orders 
  FOR UPDATE 
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'admin' AND active = true
    )
  );
CREATE POLICY "Only admins can delete work orders" 
  ON public.work_orders 
  FOR DELETE 
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'admin' AND active = true
    )
  );

CREATE TABLE public.work_order_products (
  id UUID NOT NULL DEFAULT gen_random_uuid() PRIMARY KEY,
  work_order_id UUID REFERENCES public.work_orders(id) ON DELETE CASCADE NOT NULL,
  product_id UUID REFERENCES public.products(id) ON DELETE CASCADE NOT NULL,
  total_weight NUMERIC NOT NULL CHECK (total_weight > 0),
  number_of_pouches INTEGER NOT NULL CHECK (number_of_pouches > 0),
  pouch_size NUMERIC NOT NULL CHECK (pouch_size > 0),
  created_at TIMESTAMP WITH TIME ZONE NOT NULL DEFAULT now(),
  CONSTRAINT pouch_calculation_check CHECK (pouch_size * number_of_pouches = total_weight)
);
ALTER TABLE public.work_order_products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Everyone can view work order products" 
  ON public.work_order_products 
  FOR SELECT 
  TO authenticated
  USING (true);
CREATE POLICY "Only admins can insert work order products" 
  ON public.work_order_products 
  FOR INSERT 
  TO authenticated
  WITH CHECK (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'admin' AND active = true
    )
  );
CREATE POLICY "Only admins can update work order products" 
  ON public.work_order_products 
  FOR UPDATE 
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'admin' AND active = true
    )
  );
CREATE POLICY "Only admins can delete work order products" 
  ON public.work_order_products 
  FOR DELETE 
  TO authenticated
  USING (
    EXISTS (
      SELECT 1 FROM public.profiles 
      WHERE id = auth.uid() AND role = 'admin' AND active = true
    )
  );

-- 11. CLIENTS TABLE
CREATE TABLE public.clients (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    client_code VARCHAR(20) NOT NULL UNIQUE,
    name VARCHAR(255) NOT NULL,
    office_address TEXT NOT NULL,
    company_registration_number VARCHAR(50) NOT NULL,
    office_phone_number VARCHAR(20) NOT NULL,
    contact_person VARCHAR(100) NOT NULL,
    contact_person_phone_number VARCHAR(20) NOT NULL,
    gst_number VARCHAR(15) NOT NULL,
    is_igst BOOLEAN NOT NULL DEFAULT false,
    is_active BOOLEAN NOT NULL DEFAULT true,
    discount NUMERIC(5,2) NOT NULL DEFAULT 0,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
  updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', now()) NOT NULL
  );
CREATE TRIGGER update_clients_updated_at
    BEFORE UPDATE ON public.clients
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();
ALTER TABLE public.clients ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to view clients"
    ON public.clients
    FOR SELECT
    TO authenticated
    USING (true);
CREATE POLICY "Allow admin users to insert clients"
    ON public.clients
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );
CREATE POLICY "Allow admin users to update clients"
    ON public.clients
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );
CREATE POLICY "Allow admin users to delete clients"
    ON public.clients
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );
CREATE INDEX idx_clients_client_code ON public.clients(client_code);
CREATE INDEX idx_clients_name ON public.clients(name);
CREATE INDEX idx_clients_is_active ON public.clients(is_active);

-- 12. ORDERS TABLES
CREATE TABLE public.orders (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    order_code VARCHAR(30) NOT NULL UNIQUE,
    remarks TEXT,
    order_date DATE NOT NULL,
    target_delivery_date DATE NOT NULL,
    client_id UUID NOT NULL REFERENCES public.clients(id) ON DELETE RESTRICT,
    status VARCHAR(20) NOT NULL DEFAULT 'NEW',
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', now()) NOT NULL
);
CREATE TRIGGER update_orders_updated_at
    BEFORE UPDATE ON public.orders
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();
ALTER TABLE public.orders ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to view orders"
    ON public.orders
    FOR SELECT
    TO authenticated
    USING (true);
CREATE POLICY "Allow admin users to insert orders"
    ON public.orders
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );
CREATE POLICY "Allow admin users to update orders"
    ON public.orders
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );
CREATE POLICY "Allow admin users to delete orders"
    ON public.orders
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );
CREATE INDEX idx_orders_order_code ON public.orders(order_code);
CREATE INDEX idx_orders_client_id ON public.orders(client_id);

CREATE TABLE public.order_products (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    order_id UUID NOT NULL REFERENCES public.orders(id) ON DELETE CASCADE,
    product_id UUID NOT NULL REFERENCES public.products(id) ON DELETE RESTRICT,
    pouch_size INTEGER NOT NULL,
    number_of_pouches INTEGER NOT NULL,
    total_weight NUMERIC(10,2) NOT NULL,
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    UNIQUE(order_id, product_id)
);
ALTER TABLE public.order_products ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to view order_products"
    ON public.order_products
    FOR SELECT
    TO authenticated
    USING (true);
CREATE POLICY "Allow admin users to insert order_products"
    ON public.order_products
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );
CREATE POLICY "Allow admin users to update order_products"
    ON public.order_products
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );
CREATE POLICY "Allow admin users to delete order_products"
    ON public.order_products
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );
CREATE INDEX idx_order_products_order_id ON public.order_products(order_id);
CREATE INDEX idx_order_products_product_id ON public.order_products(product_id);

-- 13. COMPANY SETTINGS TABLE
CREATE TABLE public.company_settings (
    id UUID DEFAULT gen_random_uuid() PRIMARY KEY,
    company_name VARCHAR(255) NOT NULL,
    company_logo_url TEXT,
    registration_number VARCHAR(100),
    gst_number VARCHAR(15),
    contact_number VARCHAR(20),
    qr_code_url TEXT,
    address TEXT,
    email VARCHAR(255),
    website VARCHAR(255),
    created_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc'::text, NOW()) NOT NULL,
    updated_at TIMESTAMP WITH TIME ZONE DEFAULT TIMEZONE('utc', now()) NOT NULL
);
CREATE TRIGGER update_company_settings_updated_at
    BEFORE UPDATE ON public.company_settings
    FOR EACH ROW
    EXECUTE FUNCTION public.update_updated_at_column();
ALTER TABLE public.company_settings ENABLE ROW LEVEL SECURITY;
CREATE POLICY "Allow authenticated users to view company settings"
    ON public.company_settings
    FOR SELECT
    TO authenticated
    USING (true);
CREATE POLICY "Allow admin users to insert company settings"
    ON public.company_settings
    FOR INSERT
    TO authenticated
    WITH CHECK (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );
CREATE POLICY "Allow admin users to update company settings"
    ON public.company_settings
    FOR UPDATE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );
CREATE POLICY "Allow admin users to delete company settings"
    ON public.company_settings
    FOR DELETE
    TO authenticated
    USING (
        EXISTS (
            SELECT 1 FROM public.profiles
            WHERE profiles.id = auth.uid()
            AND profiles.role = 'admin'
            AND profiles.active = true
        )
    );

-- 14. ADDITIONAL INDEXES (if any already included above, skip)
-- (Indexes for all major foreign keys and search columns are already included above)

-- 15. SEED DATA (optional, add admin/staff users as needed)
-- Example:
-- INSERT INTO public.profiles (id, username, email, role, active, created_at, updated_at)
-- VALUES ('admin-uuid', 'admin', 'admin@fmc.com', 'admin', true, now(), now());

-- End of FoodMosaic Database Schema 